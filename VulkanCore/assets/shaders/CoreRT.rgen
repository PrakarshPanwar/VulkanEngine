#version 460 core
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_shader_clock : require
#extension GL_EXT_control_flow_attributes : require

#include "Utils/Payload.glslh"
#include "Utils/Random.glslh"

layout(set = 0, binding = 0) uniform accelerationStructureEXT u_TopLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D o_Image;
layout(set = 0, binding = 2, rgba32f) uniform image2D u_AccumulationImage;

layout(set = 0, binding = 3) uniform Camera
{
	mat4 Projection;
	mat4 View;
    mat4 InverseProjection;
	mat4 InverseView;
	vec2 DepthUnpackConsts;
} u_Camera;

layout(location = 0) rayPayloadEXT RayPayload o_RayPayload;

layout(push_constant) uniform RTSettings
{
	uint SampleCount;
	uint Bounces;
	uint RandomSeed;
	uint FrameIndex;
} u_Settings;

void main()
{
	o_RayPayload.Seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), u_Settings.FrameIndex);

	uint randomSeed = u_Settings.RandomSeed;
	vec3 finalRadiance = vec3(0.0);

	const float tMin = 0.1;
	const float tMax = 1000.0;

	// Accumulate all rays for pixels
	for (uint i = 0; i < u_Settings.SampleCount; ++i)
	{
		const vec2 texCoord = vec2(gl_LaunchIDEXT.x + RandomFloat(randomSeed), gl_LaunchIDEXT.y + RandomFloat(randomSeed)) / gl_LaunchSizeEXT.xy;
		vec2 uv = texCoord * 2.0 - 1.0;

		vec4 target = u_Camera.InverseProjection * vec4(uv.x, uv.y, 1.0, 1.0);
		vec4 origin = u_Camera.InverseView * vec4(0.0, 0.0, 0.0, 1.0);
		vec4 direction = u_Camera.InverseView * vec4(normalize(target.xyz), 0.0);

		Ray rayData;
		rayData.Origin = origin.xyz;
		rayData.Direction = direction.xyz;

		BSDFSample bsdf;
		vec3 radiance = vec3(0.0);
		vec3 absorption = vec3(0.0);
		vec3 beta = vec3(1.0);

		for (uint j = 0; j < u_Settings.Bounces; ++j)
		{
			o_RayPayload.Radiance = radiance;
			o_RayPayload.Absorption = absorption;
			o_RayPayload.Beta = beta;
			o_RayPayload.RayData = rayData;
			o_RayPayload.BSDF = bsdf;
			o_RayPayload.Depth = j;
			o_RayPayload.Distance = 1.0;

			// Trace Ray
			traceRayEXT(u_TopLevelAS,
				gl_RayFlagsNoneEXT,
				0xFF,
				0,
				0,
				0,
				rayData.Origin,
				tMin,
				rayData.Direction,
				tMax,
				0);

			radiance = o_RayPayload.Radiance;
			beta = o_RayPayload.Beta;
			rayData = o_RayPayload.RayData;
			bsdf = o_RayPayload.BSDF;
			absorption = o_RayPayload.Absorption;

			// Trace Miss
			if (o_RayPayload.Distance < 0.0)
				break;
		}

		finalRadiance += radiance;
	}

	finalRadiance /= float(u_Settings.SampleCount);

	const bool accumulate = u_Settings.FrameIndex > 1;
	const vec4 accumulationColor = accumulate ? imageLoad(u_AccumulationImage, ivec2(gl_LaunchIDEXT.xy)) : vec4(0.0);
	vec3 accumulatedColor = accumulationColor.rgb + finalRadiance;

	finalRadiance = accumulatedColor / float(u_Settings.FrameIndex);

	imageStore(o_Image, ivec2(gl_LaunchIDEXT.xy), vec4(finalRadiance, 1.0));
	imageStore(u_AccumulationImage, ivec2(gl_LaunchIDEXT.xy), vec4(accumulatedColor, 1.0));
}
