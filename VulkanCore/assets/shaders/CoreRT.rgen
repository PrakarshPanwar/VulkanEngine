#version 460 core
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_shader_clock : require
#extension GL_EXT_control_flow_attributes : require

layout(set = 0, binding = 0) uniform accelerationStructureEXT u_TopLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D o_Image;
layout(set = 0, binding = 2, rgba32f) uniform image2D u_AccumulationImage;

layout(set = 0, binding = 3) uniform Camera
{
	mat4 Projection;
	mat4 View;
    mat4 InverseProjection;
	mat4 InverseView;
	vec2 DepthUnpackConsts;
} u_Camera;

struct RayPayload
{
	vec3 Color;
	vec4 ScatterDirection;
	float Distance;
	uint Seed;
};

layout(location = 0) rayPayloadEXT RayPayload o_RayPayload;

layout(push_constant) uniform RTSettings
{
	uint SampleCount;
	uint Bounces;
	uint RandomSeed;
	uint FrameIndex;
} u_Settings;

uint InitRandomSeed(uint val0, uint val1)
{
	uint v0 = val0, v1 = val1, s0 = 0;

	[[unroll]] 
	for (uint n = 0; n < 16; n++)
	{
		s0 += 0x9e3779b9;
		v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
		v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
	}

	return v0;
}

uint RandomInt(inout uint seed)
{
	// LCG values from Numerical Recipes
    return (seed = 1664525 * seed + 1013904223);
}

float RandomFloat(inout uint seed)
{
	// Float version using bitmask from Numerical Recipes
	const uint one = 0x3f800000;
	const uint msk = 0x007fffff;
	return uintBitsToFloat(one | (msk & (RandomInt(seed) >> 9))) - 1;
}

vec2 RandomInUnitDisk(inout uint seed)
{
	for (;;)
	{
		const vec2 p = 2 * vec2(RandomFloat(seed), RandomFloat(seed)) - 1;
		if (dot(p, p) < 1)
		{
			return p;
		}
	}
}

vec3 RandomInUnitSphere(inout uint seed)
{
	for (;;)
	{
		const vec3 p = 2 * vec3(RandomFloat(seed), RandomFloat(seed), RandomFloat(seed)) - 1;
		if (dot(p, p) < 1)
		{
			return p;
		}
	}
}

void main()
{
	o_RayPayload.Seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), u_Settings.FrameIndex);

	uint pixelRandomSeed = u_Settings.RandomSeed;
	vec3 pixelColor = vec3(0.0);

	// Accumulate all rays for pixels
	for (uint i = 0; i < u_Settings.SampleCount; ++i)
	{
		const vec2 texCoord = vec2(gl_LaunchIDEXT.x + RandomFloat(pixelRandomSeed), gl_LaunchIDEXT.y + RandomFloat(pixelRandomSeed)) / gl_LaunchSizeEXT.xy;
		vec2 uv = texCoord * 2.0 - 1.0;

		vec4 origin = u_Camera.InverseView * vec4(0.0, 0.0, 0.0, 1.0);
		vec4 target = u_Camera.InverseProjection * vec4(uv.x, uv.y, 1.0, 1.0);
		vec4 direction = u_Camera.InverseView * vec4(normalize(target.xyz), 0.0);
		vec3 rayColor = vec3(1.0);

		const float tMin = 0.1;
		const float tMax = 1000.0;

		for (uint j = 0; j <= u_Settings.Bounces; ++j)
		{
			if (j == u_Settings.Bounces)
			{
				rayColor = vec3(0.0);
				break;
			}
			
			// Trace Ray
			traceRayEXT(u_TopLevelAS,
				gl_RayFlagsOpaqueEXT,
				0xFF,
				0,
				0,
				0,
				origin.xyz,
				tMin,
				direction.xyz,
				tMax,
				0);

			const vec3 hitColor = o_RayPayload.Color;
			const float hitDistance = o_RayPayload.Distance;

			rayColor *= hitColor;

			// Trace Miss
			if (hitDistance < 0 || o_RayPayload.ScatterDirection.w < 0)
			{
				break;
			}

			// Trace Hit
			origin = origin + hitDistance * direction;
			direction = vec4(o_RayPayload.ScatterDirection.xyz, 0.0);
		}

		pixelColor += rayColor;
	}

	const bool accumulate = u_Settings.FrameIndex > 1;
	const vec4 accumulationColor = accumulate ? imageLoad(u_AccumulationImage, ivec2(gl_LaunchIDEXT.xy)) : vec4(0.0);
	vec3 accumulatedColor = accumulationColor.rgb + pixelColor;

	pixelColor = accumulatedColor / float(u_Settings.FrameIndex);

	imageStore(o_Image, ivec2(gl_LaunchIDEXT.xy), vec4(pixelColor, 1.0));
	imageStore(u_AccumulationImage, ivec2(gl_LaunchIDEXT.xy), vec4(accumulatedColor, 1.0));
}
