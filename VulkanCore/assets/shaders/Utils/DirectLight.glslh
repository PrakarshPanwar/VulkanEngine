#pragma once

vec4 EnvironmentSample(inout vec3 color)
{
	float r1 = RandomFloat(o_RayPayload.Seed);
	float r2 = RandomFloat(o_RayPayload.Seed);

	float v = texture(u_PDFTexture, vec2(0.0, r1)).x; // Marginal
	float u = texture(u_CDFTexture, vec2(r2, v)).x;  // Conditional

	color = texture(u_HDRTexture, vec2(u, v)).xyz * u_Skybox.Intensity;
	float pdf = texture(u_CDFTexture, vec2(u, v)).y * texture(u_PDFTexture, vec2(0.0, v)).y;

	float phi = u * TWO_PI;
	float theta = v * PI;

	if (sin(theta) == 0.0)
		pdf = 0.0;

	return vec4(
		-sin(theta) * cos(phi), 
		cos(theta),
		-sin(theta) * sin(phi),
		(pdf * HDR_RESOLUTION) / (TWO_PI * PI * sin(theta))
	);
}

vec3 DirectLight(in Material material)
{
	vec3 L = vec3(0);
	float tMin = gl_RayTminEXT;
	float tMax = gl_RayTmaxEXT;

	BSDFSample bsdfSample;

	vec3 surfacePosition = o_RayPayload.WorldPosition;

	// Environment Light
	vec3 color = vec3(0.0);
	vec4 dirPdf = EnvironmentSample(color);
	vec3 lightDir = dirPdf.xyz;
	float lightPdf = dirPdf.w;

	o_CastShadow = true;

	// Shadow Ray (payload 1 is Shadow.rmiss)
	traceRayEXT(u_TopLevelAS,
		gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
		0xFF,
		0,
		0,
		1,
		surfacePosition,
		tMin,
		lightDir,
		tMax,
		1);

	if (!o_CastShadow)
	{
		vec3 F = DisneyEval(material, lightDir, bsdfSample.PDF);

		float cosTheta = abs(dot(lightDir, o_RayPayload.FFNormal));
		float misWeight = PowerHeuristic(lightPdf, bsdfSample.PDF);

		if (misWeight > 0.0)
			L += misWeight * F * cosTheta * color / (lightPdf + EPS);
	}

	if (u_PointLight.Count > 0)
	{
		int lightIndex = min(u_PointLight.Count - 1, int(RandomFloat(o_RayPayload.Seed) * float(u_PointLight.Count)));
		PointLight pointLight = u_PointLight.PointLights[lightIndex];

		LightSample sampled = SampleLight(pointLight);	
		vec3 lightDir       = sampled.Position - surfacePosition;
		float lightDist     = length(lightDir);
		float lightDistSq   = lightDist * lightDist;
		lightDir = normalize(lightDir);

		o_CastShadow = true;

		// Light has to be visible from the Surface. Less than 90° between vectors.
		if (dot(o_RayPayload.FFNormal, lightDir) <= 0.0 || dot(lightDir, sampled.Normal) >= 0.0)
			return L;

		// Shadow ray (payload 1 is Shadow.rmiss)
		traceRayEXT(u_TopLevelAS,
			gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
			0xFF,
			0,
			0,
			1,
			surfacePosition,
			tMin,
			lightDir,
			lightDist,
			1);
		
		if (!o_CastShadow)
		{
			vec3 F = DisneyEval(material, lightDir, bsdfSample.PDF);

			float lightPdf = lightDistSq / (2 * TWO_PI * pointLight.Radius * pointLight.Radius * abs(dot(sampled.Normal, lightDir)));
			float cosTheta = abs(dot(o_RayPayload.FFNormal, lightDir));
			float misWeight = PowerHeuristic(lightPdf, bsdfSample.PDF);

			L += misWeight * F * cosTheta * sampled.Emission / (lightPdf + EPS);
		}
	}

	return L;
}
