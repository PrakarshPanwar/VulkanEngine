#pragma once

vec3 DirectLight(in Material material)
{
	vec3 L = vec3(0);
	float tMin = gl_RayTminEXT;
	float tMax = gl_RayTmaxEXT;

	BSDFSample bsdfSample;

	vec3 surfacePosition = o_RayPayload.WorldPosition;

#if 0
	// Environment Light
	vec3 color = vec3(0.0);
	vec4 dirPdf = envSample(color);
	vec3 lightDir = dirPdf.xyz;
	float lightPdf = dirPdf.w;

	o_CastShadow = true;

	// Shadow Ray (payload 1 is Shadow.rmiss)
	traceRayEXT(u_TopLevelAS,
		gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
		0xFF,
		0,
		0,
		1,
		surfacePosition,
		tMin,
		lightDir,
		tMax,
		1);

	if (!o_CastShadow)
	{
		vec3 F = DisneyEval(material, lightDir, bsdfSample.PDF);

		float cosTheta = abs(dot(lightDir, o_RayPayload.FFNormal));
		float misWeight = PowerHeuristic(lightPdf, bsdfSample.PDF);

		if (misWeight > 0.0)
			L += misWeight * F * cosTheta * color / (lightPdf + EPS);
	}
#endif

	if (u_PointLight.Count > 0)
	{
		int lightIndex = min(u_PointLight.Count - 1, int(RandomFloat(o_RayPayload.Seed) * float(u_PointLight.Count)));
		PointLight pointLight = u_PointLight.PointLights[lightIndex];

		LightSample sampled = SampleLight(pointLight);	
		vec3 lightDir       = sampled.Position - surfacePosition;
		float lightDist     = length(lightDir);
		float lightDistSq   = lightDist * lightDist;
		lightDir = normalize(lightDir);

		o_CastShadow = true;

		// Light has to be visible from the Surface. Less than 90° between vectors.
		if (dot(o_RayPayload.FFNormal, lightDir) <= 0.0 || dot(lightDir, sampled.Normal) >= 0.0)
			return L;

		// Shadow ray (payload 1 is Shadow.miss)
		traceRayEXT(u_TopLevelAS,
			gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
			0xFF,
			0,
			0,
			1,
			surfacePosition,
			tMin,
			lightDir,
			lightDist,
			1);
		
		if (!o_CastShadow)
		{
			vec3 F = DisneyEval(material, lightDir, bsdfSample.PDF);

			float lightPdf = lightDistSq / (2 * TWO_PI * pointLight.Radius * pointLight.Radius * abs(dot(sampled.Normal, lightDir)));
			float cosTheta = abs(dot(o_RayPayload.FFNormal, lightDir));
			float misWeight = PowerHeuristic(lightPdf, bsdfSample.PDF);

			L += misWeight * F * cosTheta * sampled.Emission / (lightPdf + EPS);
		}
	}

	return L;
}
