// GLSL Header: BSDF.glslh

vec3 EvalDielectricReflection(vec3 V, vec3 N, vec3 L, vec3 H, inout float pdf)
{
    pdf = 0.0;
    if (dot(N, L) <= 0.0)
        return vec3(0.0);

    float eta = o_RayPayload.ETA;
    float F = FresnelDielectric(dot(V, H), eta);
    float D = GTR2(dot(N, H), m_Params.Roughness);

    pdf = D * dot(N, H) * F / (4.0 * abs(dot(V, H)));
    float G = GeometrySmithGGX(abs(dot(N, L)), m_Params.Roughness) * GeometrySmithGGX(abs(dot(N, V)), m_Params.Roughness);
    
    return m_Params.Albedo * F * D * G;
}

vec3 EvalDielectricRefraction(vec3 V, vec3 N, vec3 L, vec3 H, inout float pdf)
{
    float eta = o_RayPayload.ETA;

    pdf = 0.0;
    if (dot(N, L) >= 0.0)
        return vec3(0.0);

    float F = FresnelDielectric(abs(dot(V, H)), eta);
    float D = GTR2(dot(N, H), m_Params.Roughness);
    float denomSqrt = dot(L, H) + dot(V, H) * eta;
    pdf = D * dot(N, H) * (1.0 - F) * abs(dot(L, H)) / (denomSqrt * denomSqrt);
    float G = GeometrySmithGGX(abs(dot(N, L)), m_Params.Roughness) * GeometrySmithGGX(abs(dot(N, V)), m_Params.Roughness);

    return m_Params.Albedo * (1.0 - F) * D * G * abs(dot(V, H)) * abs(dot(L, H)) * 4.0 * eta * eta / (denomSqrt * denomSqrt);
}

vec3 EvalSpecular(in vec3 Cspec0, vec3 V, vec3 N, vec3 L, vec3 H, inout float pdf)
{
    pdf = 0.0;
    if (dot(N, L) <= 0.0)
        return vec3(0.0);

    float D = GTR2(dot(N, H), m_Params.Roughness);
    pdf = D * dot(N, H) / (4.0 * dot(V, H));
    float FH = FresnelSchlick(dot(L, H));
    vec3 F = mix(Cspec0, vec3(1.0), FH);
    float G = GeometrySmithGGX(abs(dot(N, L)), m_Params.Roughness) * GeometrySmithGGX(abs(dot(N, V)), m_Params.Roughness);

    return F * D * G;
}

vec3 EvalMicrofacetReflection(vec3 V, vec3 N, vec3 L, vec3 H, vec3 F, out float pdf)
{
    pdf = 0.0;
    if (dot(N, L) <= 0.0)
        return vec3(0.0);

    V = V * Input.WorldNormals;
    L = L * Input.WorldNormals;

    float D = GTR2Aniso(H.z, H.x, H.y, m_Params.Anisotropy);
    float G1 = SmithGAniso(abs(V.z), V.x, V.y, m_Params.Anisotropy);
    float G2 = G1 * SmithGAniso(abs(L.z), L.x, L.y, m_Params.Anisotropy);

    pdf = G1 * D / (4.0 * V.z);
    return F * D * G2 / (4.0 * L.z * V.z);
}

vec3 EvalMicrofacetRefraction(vec3 V, vec3 N, vec3 L, vec3 H, vec3 F, float eta, out float pdf)
{
    pdf = 0.0;
    if (dot(N, L) >= 0.0)
        return vec3(0.0);

    V = V * Input.WorldNormals;
    L = L * Input.WorldNormals;

    float dotLH = dot(L, H);
    float dotVH = dot(V, H);

    float D = GTR2Aniso(H.z, H.x, H.y, m_Params.Anisotropy);
    float G1 = SmithGAniso(abs(V.z), V.x, V.y, m_Params.Anisotropy);
    float G2 = G1 * SmithGAniso(abs(L.z), L.x, L.y, m_Params.Anisotropy);
    float denom = dotLH + dotVH * eta;
    denom *= denom;
    float eta2 = eta * eta;
    float jacobian = abs(dotLH) / denom;

    pdf = G1 * max(0.0, dotVH) * D * jacobian / V.z;
    return pow(m_Params.Albedo, vec3(0.5)) * (1.0 - F) * D * G2 * abs(dotVH) * jacobian * eta2 / abs(L.z * V.z);
}

vec3 EvalClearcoat(vec3 V, vec3 N, vec3 L, vec3 H, inout float pdf)
{
    pdf = 0.0;
    if (dot(N, L) <= 0.0)
        return vec3(0.0);

    float D = GTR1(dot(N, H), mix(0.1, 0.001, u_RTMaterialData.ClearcoatGloss));
    pdf = D * dot(N, H) / (4.0 * dot(V, H));
    float FH = FresnelSchlick(dot(L, H));
    float F = mix(0.04, 1.0, FH);
    float G = GeometrySmithGGX(dot(N, L), 0.25) * GeometrySmithGGX(dot(N, V), 0.25);

    return vec3(0.25 * u_RTMaterialData.Clearcoat * F * D * G);
}

vec3 EvalDiffuse(in vec3 Csheen, vec3 V, vec3 N, vec3 L, vec3 H, inout float pdf)
{
    pdf = 0.0;
    if (dot(N, L) <= 0.0)
        return vec3(0.0);

    pdf = dot(N, L) * (1.0 / PI);

    // Diffuse
    float FL = FresnelSchlick(dot(N, L));
    float FV = FresnelSchlick(dot(N, V));
    float FH = FresnelSchlick(dot(L, H));
    float Fd90 = 0.5 + 2.0 * dot(L, H) * dot(L, H) * m_Params.Roughness;
    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);

    // Fake Subsurface TODO: Replace with Volumetric Scattering
    float Fss90 = dot(L, H) * dot(L, H) * m_Params.Roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1.0 / (dot(N, L) + dot(N, V)) - 0.5) + 0.5);

    vec3 Fsheen = FH * u_RTMaterialData.Sheen * Csheen;

    return ((1.0 / PI) * mix(Fd, ss, u_RTMaterialData.Subsurface) * m_Params.Albedo + Fsheen) * (1.0 - m_Params.Metallic);
}

vec3 DisneySample(in Material material, inout vec3 L, inout float pdf)
{
    pdf = 0.0;
    vec3 Fr = vec3(0.0);

    float diffuseRatio = 0.5 * (1.0 - m_Params.Metallic);
    float transWeight = (1.0 - m_Params.Metallic) * u_RTMaterialData.Transmission;

    vec3 Cdlin = m_Params.Albedo;
    float Cdlum = 0.212671 * Cdlin.x + 0.715160 * Cdlin.y + 0.072169 * Cdlin.z; // Luminance approximation

    vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize Luminance to isolate Hue + Saturation
    vec3 Cspec0 = mix(material.Albedo.w * 0.08 * mix(vec3(1.0), Ctint, u_RTMaterialData.SpecularTint), Cdlin, m_Params.Metallic);
    vec3 Csheen = mix(vec3(1.0), Ctint, u_RTMaterialData.SheenTint);
    float eta = o_RayPayload.ETA;

    vec3 N = o_RayPayload.FFNormal;
    vec3 V = -gl_WorldRayDirectionEXT;

    float r1 = RandomFloat(o_RayPayload.Seed);
    float r2 = RandomFloat(o_RayPayload.Seed);

    if (RandomFloat(o_RayPayload.Seed) < transWeight)
    {
        vec3 H = ImportanceSampleGTR2(m_Params.Roughness, r1, r2);
        H = Input.WorldNormals * H;

        if (dot(V, H) < 0.0)
            H = -H;

        vec3 R = reflect(-V, H);
        float F = FresnelDielectric(abs(dot(R, H)), eta);

        if (r2 < F) // Reflection/Total Internal Reflection
        {
            L = normalize(R);
            Fr = EvalDielectricReflection(V, N, L, H, pdf);
        }
        else // Transmission
        {
            L = normalize(refract(-V, H, eta));
            Fr = EvalDielectricRefraction(V, N, L, H, pdf);
        }

        Fr *= transWeight;
        pdf *= transWeight;
    }
    else
    {
        if (RandomFloat(o_RayPayload.Seed) < diffuseRatio)
        {
            L = CosSampleHemisphere(o_RayPayload.Seed);
            L = Input.WorldNormals * L;

            vec3 H = normalize(L + V);

            Fr = EvalDiffuse(Csheen, V, N, L, H, pdf);
            pdf *= diffuseRatio;
        }
        else // Specular
        {
            float primarySpecRatio = 1.0 / (1.0 + u_RTMaterialData.Clearcoat);

            // Sample Primary Specular Lobe
            if (RandomFloat(o_RayPayload.Seed) < primarySpecRatio)
            {
                // TODO: Implement http://jcgt.org/published/0007/04/01/ (Microfacet Anisotropy)
                vec3 H = SampleGGXVNDF(V, m_Params.Anisotropy, r1, r2);
                H = Input.WorldNormals * H;

                if (dot(V, H) < 0.0)
                    H = -H;

                L = normalize(reflect(-V, H));

                Fr = EvalSpecular(Cspec0, V, N, L, H, pdf);
                pdf *= primarySpecRatio * (1.0 - diffuseRatio);
            }
            else // Sample Clearcoat Lobe
            {
                vec3 H = ImportanceSampleGTR1(mix(0.1, 0.001, u_RTMaterialData.ClearcoatGloss), r1, r2);
                H = Input.WorldNormals * H;

                if (dot(V, H) < 0.0)
                    H = -H;

                L = normalize(reflect(-V, H));

                Fr = EvalClearcoat(V, N, L, H, pdf);
                pdf *= (1.0 - primarySpecRatio) * (1.0 - diffuseRatio);
            }
        }

        Fr *= (1.0 - transWeight);
        pdf *= (1.0 - transWeight);
    }

    return Fr;
}

vec4 EnvironmentSample(inout vec3 color)
{
	float r1 = RandomFloat(o_RayPayload.Seed);
	float r2 = RandomFloat(o_RayPayload.Seed);

	float v = texture(u_PDFTexture, vec2(0.0, r1)).x; // Marginal
	float u = texture(u_CDFTexture, vec2(r2, v)).x;   // Conditional

	color = texture(u_HDRTexture, vec2(u, v)).xyz * u_Skybox.Intensity;
	float pdf = texture(u_CDFTexture, vec2(u, v)).y * texture(u_PDFTexture, vec2(0.0, v)).y;

	float phi = u * TWO_PI;
	float theta = v * PI;

	if (sin(theta) == 0.0)
		pdf = 0.0;

	return vec4(
		-sin(theta) * cos(phi), 
		cos(theta),
		-sin(theta) * sin(phi),
		(pdf * HDR_RESOLUTION) / (TWO_PI * PI * sin(theta))
	);
}

vec3 DisneyEval(Material material, vec3 L, inout float pdf)
{
    vec3 N = o_RayPayload.FFNormal;
    vec3 V = -gl_WorldRayDirectionEXT;
    float eta = o_RayPayload.ETA;

    vec3 H = vec3(0.0);
    bool reflection = dot(N, L) > 0.0;

    if (reflection)
        H = normalize(L + V);
    else
        H = normalize(L + V * eta);

    if (dot(V, H) < 0.0)
        H = -H;

    float diffuseRatio = 0.5 * (1.0 - m_Params.Metallic);
    float primarySpecRatio = 1.0 / (1.0 + u_RTMaterialData.Clearcoat);
    float transWeight = (1.0 - m_Params.Metallic) * u_RTMaterialData.Transmission;

    vec3 brdf = vec3(0.0);
    vec3 bsdf = vec3(0.0);
    float brdfPdf = 0.0;
    float bsdfPdf = 0.0;

    if (transWeight > 0.0)
    {
        if (reflection) // Reflection
        {
            bsdf = EvalDielectricReflection(V, N, L, H, bsdfPdf);
        }
        else // Transmission
        {
            bsdf = EvalDielectricRefraction(V, N, L, H, bsdfPdf);
        }
    }

    float tpdf = 0.0;
    if (transWeight < 1.0)
    {
        vec3 Cdlin = m_Params.Albedo;
        float Cdlum = 0.212671 * Cdlin.x + 0.715160 * Cdlin.y + 0.072169 * Cdlin.z; // Luminance approximation

        vec3 Ctint = Cdlum > 0.0 ? Cdlin / Cdlum : vec3(1.0); // normalize Luminance to isolate Hue + Saturation
        vec3 Cspec0 = mix(material.Albedo.w * 0.08 * mix(vec3(1.0), Ctint, u_RTMaterialData.SpecularTint), Cdlin, m_Params.Metallic);
        vec3 Csheen = mix(vec3(1.0), Ctint, u_RTMaterialData.SheenTint);

        // Diffuse
        brdf += EvalDiffuse(Csheen, V, N, L, H, tpdf);
        brdfPdf += tpdf * diffuseRatio;

        // Specular
        brdf += EvalSpecular(Cspec0, V, N, L, H, tpdf);
        brdfPdf += tpdf * primarySpecRatio * (1.0 - diffuseRatio);

        // Clearcoat
        brdf += EvalClearcoat(V, N, L, H, tpdf);
        brdfPdf += tpdf * (1.0 - primarySpecRatio) * (1.0 - diffuseRatio);
    }

    pdf = mix(brdfPdf, bsdfPdf, transWeight);

    return mix(brdf, bsdf, transWeight);
}

vec3 DirectLight(in Material material)
{
	vec3 L = vec3(0);
	float tMin = gl_RayTminEXT;
	float tMax = gl_RayTmaxEXT;

	BSDFSample bsdfSample;

	vec3 surfacePosition = o_RayPayload.WorldPosition;

	// Environment Light
	vec3 color = vec3(0.0);
	vec4 dirPdf = EnvironmentSample(color);
	vec3 lightDir = dirPdf.xyz;
	float lightPdf = dirPdf.w;

	o_CastShadow = false;

	// Shadow Ray (payload 1 is Shadow.rmiss)
	traceRayEXT(u_TopLevelAS,
		gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
		0xFF,
		0,
		0,
		1,
		surfacePosition,
		tMin,
		lightDir,
		tMax,
		1);

	if (o_CastShadow)
	{
		vec3 F = DisneyEval(material, lightDir, bsdfSample.PDF);

		float cosTheta = abs(dot(lightDir, o_RayPayload.FFNormal));
		float misWeight = PowerHeuristic(lightPdf, bsdfSample.PDF);

		if (misWeight > 0.0)
			L += misWeight * F * cosTheta * color / (lightPdf + EPS);
	}

	if (u_PointLight.Count > 0)
	{
		int lightIndex = min(u_PointLight.Count - 1, int(RandomFloat(o_RayPayload.Seed) * float(u_PointLight.Count)));
		PointLight pointLight = u_PointLight.PointLights[lightIndex];

		LightSample sampled = SampleLight(pointLight);
		vec3 lightDir       = sampled.Position - surfacePosition;
		float lightDist     = length(lightDir);
		float lightDistSq   = lightDist * lightDist;
		lightDir = normalize(lightDir);

		o_CastShadow = false;

		// Light has to be visible from the Surface. Less than 90° between vectors.
		if (dot(o_RayPayload.FFNormal, lightDir) <= 0.0 || dot(lightDir, sampled.Normal) >= 0.0)
			return L;

		// Shadow ray (payload 1 is Shadow.rmiss)
		traceRayEXT(u_TopLevelAS,
			gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
			0xFF,
			0,
			0,
			1,
			surfacePosition,
			tMin,
			lightDir,
			lightDist,
			1);
		
		if (o_CastShadow)
		{
			vec3 F = DisneyEval(material, lightDir, bsdfSample.PDF);

			float lightPdf = lightDistSq / (2 * TWO_PI * pointLight.Radius * pointLight.Radius * abs(dot(sampled.Normal, lightDir)));
			float cosTheta = abs(dot(o_RayPayload.FFNormal, lightDir));
			float misWeight = PowerHeuristic(lightPdf, bsdfSample.PDF);

			L += misWeight * F * cosTheta * sampled.Emission / (lightPdf + EPS);
		}
	}

	return L;
}
